<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm ‚ô°</title>
    <style>
        body { 
            margin: 0; 
            font-family: 'Comic Sans MS', 'Chalkboard', cursive;
            background: linear-gradient(to bottom, #ffe6f2, #fff0f8);
            text-align: center;
            color: #d63384;
        }
        h1 {
            font-size: 56px;
            margin: 40px 0 10px;
            color: #ff69b4;
            text-shadow: 3px 3px 6px rgba(255,105,180,0.4);
        }
        .subtitle {
            font-size: 32px;
            margin-bottom: 40px;
            color: #ff1493;
            font-style: italic;
        }
        .flowers {
            font-size: 60px;
            margin: 20px 0;
        }
        canvas { 
            display: block; 
            background: #ffffff;
            margin: 30px auto; 
            box-shadow: 0 10px 30px rgba(255,105,180,0.3);
            border: 8px solid #ffb6c1;
            border-radius: 30px;
        }
        .controls {
            margin: 30px;
            padding: 20px;
            background: #fff0f8;
            border-radius: 20px;
            display: inline-block;
            box-shadow: 0 5px 15px rgba(255,182,193,0.4);
        }
        button {
            padding: 14px 28px;
            margin: 10px;
            font-size: 22px;
            cursor: pointer;
            border: none;
            border-radius: 50px;
            background: #ff69b4;
            color: white;
            box-shadow: 0 4px 10px rgba(255,105,180,0.4);
        }
        button:hover { 
            background: #ff1493; 
            transform: scale(1.05);
        }
        select, input[type="range"] { 
            padding: 12px; 
            font-size: 20px; 
            margin: 10px;
            border-radius: 20px;
            border: 3px solid #ffb6c1;
        }
        #info { 
            font-size: 24px; 
            margin: 20px;
            min-height: 40px;
            color: #d63384;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="flowers">üå∏ üå∑ üå∫ üåº üåª</div>
    <h1>To Jack Dykstra, Gal‚Äôs secret buddy ‚ù§Ô∏è</h1>
    <div class="subtitle">A super cute gift: Dijkstra's Shortest Paths Algorithm ‚ô°</div>
    <div class="flowers">üå∑ üå∏ üå∫ üåº üåª</div>

    <div class="controls">
        <button id="run">‚ú® Run Magic Paths ‚ú®</button>
        <button id="reset">üîÑ Start Over</button><br>
        <label>Start from: <select id="start"></select></label>
        <label>Speed: <input type="range" id="speed" min="300" max="3000" value="1200" step="300"></label>
    </div>
    <div id="info">Pick a start and press the pink button to see the magic! ‚ô°</div>
    <canvas id="canvas" width="1000" height="700"></canvas>
    <div class="flowers">üå∏ üå∑ üå∫ üåº üåª</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startSelect = document.getElementById('start');
        const runBtn = document.getElementById('run');
        const resetBtn = document.getElementById('reset');
        const speedSlider = document.getElementById('speed');
        const info = document.getElementById('info');

        // 10 cute nodes
        const nodes = [
            { id: 'A', x: 150, y: 250 },
            { id: 'B', x: 300, y: 100 },
            { id: 'C', x: 300, y: 400 },
            { id: 'D', x: 500, y: 200 },
            { id: 'E', x: 500, y: 400 },
            { id: 'F', x: 700, y: 100 },
            { id: 'G', x: 700, y: 300 },
            { id: 'H', x: 700, y: 500 },
            { id: 'I', x: 850, y: 250 },
            { id: 'J', x: 450, y: 550 }
        ];

        const edges = [
            { from: 'A', to: 'B', weight: 5 },
            { from: 'A', to: 'C', weight: 3 },
            { from: 'B', to: 'D', weight: 8 },
            { from: 'B', to: 'F', weight: 12 },
            { from: 'C', to: 'D', weight: 4 },
            { from: 'C', to: 'J', weight: 7 },
            { from: 'D', to: 'E', weight: 6 },
            { from: 'D', to: 'G', weight: 9 },
            { from: 'E', to: 'H', weight: 5 },
            { from: 'E', to: 'J', weight: 10 },
            { from: 'F', to: 'G', weight: 3 },
            { from: 'F', to: 'I', weight: 7 },
            { from: 'G', to: 'H', weight: 4 },
            { from: 'G', to: 'I', weight: 6 },
            { from: 'H', to: 'I', weight: 8 },
            { from: 'H', to: 'J', weight: 11 }
        ];

        const curvedEdges = [
            { from: 'B', to: 'F', cpX: 500, cpY: 50 },
            { from: 'C', to: 'J', cpX: 400, cpY: 500 },
            { from: 'D', to: 'G', cpX: 600, cpY: 150 },
            { from: 'E', to: 'J', cpX: 600, cpY: 550 },
            { from: 'F', to: 'I', cpX: 800, cpY: 50 }
        ];

        const graph = {};
        nodes.forEach(node => graph[node.id] = []);
        edges.forEach(edge => {
            graph[edge.from].push({ node: edge.to, weight: edge.weight });
            graph[edge.to].push({ node: edge.from, weight: edge.weight });
        });

        let distances = {};
        let previous = {};
        let visited = new Set();
        let current = null;
        let shortestPaths = {};
        let animationInterval = null;

        function isCurved(from, to) {
            return curvedEdges.find(e => 
                (e.from === from && e.to === to) || (e.from === to && e.to === from)
            );
        }

        function getControlPoint(from, to) {
            const edge = curvedEdges.find(e => 
                (e.from === from && e.to === to) || (e.from === to && e.to === from)
            );
            return edge ? { cpX: edge.cpX, cpY: edge.cpY } : null;
        }

        function drawEdge(fromNode, toNode, weight, isShortest = false) {
            ctx.strokeStyle = isShortest ? '#ff69b4' : '#ffc0cb';
            ctx.lineWidth = isShortest ? 10 : 5;
            ctx.lineCap = 'round';

            const cp = isCurved(fromNode.id, toNode.id) ? getControlPoint(fromNode.id, toNode.id) : null;

            ctx.beginPath();
            if (cp) {
                ctx.moveTo(fromNode.x, fromNode.y);
                ctx.quadraticCurveTo(cp.cpX, cp.cpY, toNode.x, toNode.y);
            } else {
                ctx.moveTo(fromNode.x, fromNode.y);
                ctx.lineTo(toNode.x, toNode.y);
            }
            ctx.stroke();

            let midX, midY;
            if (cp) {
                midX = (fromNode.x + 2*cp.cpX + toNode.x) / 4;
                midY = (fromNode.y + 2*cp.cpY + toNode.y) / 4;
            } else {
                midX = (fromNode.x + toNode.x) / 2;
                midY = (fromNode.y + toNode.y) / 2;
            }

            ctx.fillStyle = '#d63384';
            ctx.font = 'bold 24px Comic Sans MS';
            ctx.fillText(weight, midX + 10, midY - 10);
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            edges.forEach(edge => {
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                const key = [edge.from, edge.to].sort().join('-');
                drawEdge(fromNode, toNode, edge.weight, !!shortestPaths[key]);
            });

            nodes.forEach(node => {
                let color = '#ffb6c1';
                if (visited.has(node.id)) {
                    color = '#ff99cc';
                } else if (current === node.id) {
                    color = '#ff69b4';
                }

                // Draw cute node (pink circle with white border)
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 50, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ff1493';
                ctx.lineWidth = 6;
                ctx.stroke();

                // Letter inside
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 48px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id, node.x, node.y);

                // Distance
                if (distances[node.id] < Infinity) {
                    ctx.fillStyle = '#d63384';
                    ctx.font = '28px Comic Sans MS';
                    ctx.fillText(distances[node.id], node.x, node.y + 80);
                }
            });
        }

        function resetVisualization() {
            distances = {};
            previous = {};
            visited.clear();
            current = null;
            shortestPaths = {};
            nodes.forEach(n => distances[n.id] = Infinity);
            info.textContent = 'Pick a start and press the pink button to see the magic! ‚ô°';
            drawGraph();
        }

        function runDijkstraStepByStep(startNode) {
            nodes.forEach(n => {
                distances[n.id] = Infinity;
                previous[n.id] = null;
            });
            distances[startNode] = 0;

            const unvisited = new Set(nodes.map(n => n.id));

            const step = () => {
                if (unvisited.size === 0) {
                    clearInterval(animationInterval);
                    highlightShortestPaths();
                    info.textContent = 'Yay! All done! The bright pink paths are the shortest ones ‚ô°';
                    return;
                }

                let minDist = Infinity;
                let nextNode = null;
                unvisited.forEach(id => {
                    if (distances[id] < minDist) {
                        minDist = distances[id];
                        nextNode = id;
                    }
                });

                current = nextNode;
                visited.add(nextNode);
                unvisited.delete(nextNode);

                graph[nextNode].forEach(neighbor => {
                    if (!visited.has(neighbor.node)) {
                        const alt = distances[nextNode] + neighbor.weight;
                        if (alt < distances[neighbor.node]) {
                            distances[neighbor.node] = alt;
                            previous[neighbor.node] = nextNode;
                        }
                    }
                });

                info.textContent = `Visiting ${nextNode} ‚ô° Distance: ${distances[nextNode]}`;
                drawGraph();
            };

            clearInterval(animationInterval);
            animationInterval = setInterval(step, parseInt(speedSlider.value));
            step();
        }

        function highlightShortestPaths() {
            shortestPaths = {};
            nodes.forEach(node => {
                if (node.id !== startSelect.value && previous[node.id]) {
                    let curr = node.id;
                    while (previous[curr]) {
                        const prev = previous[curr];
                        const key = [prev, curr].sort().join('-');
                        shortestPaths[key] = true;
                        curr = prev;
                    }
                }
            });
            drawGraph();
        }

        nodes.forEach(node => {
            const opt = document.createElement('option');
            opt.value = node.id;
            opt.textContent = node.id;
            startSelect.appendChild(opt);
        });
        startSelect.value = 'A';

        runBtn.addEventListener('click', () => {
            resetVisualization();
            distances[startSelect.value] = 0;
            runDijkstraStepByStep(startSelect.value);
        });

        resetBtn.addEventListener('click', resetVisualization);

        speedSlider.addEventListener('input', () => {
            if (animationInterval) {
                clearInterval(animationInterval);
                runDijkstraStepByStep(startSelect.value);
            }
        });

        resetVisualization();
    </script>
</body>
</html>
